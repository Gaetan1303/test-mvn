# Fiche de synth√®se ‚Äî Architecture & Principes SOLID

## 1. Architecture globale

L‚Äôapplication repose sur une **architecture hybride** combinant :
- **Backend Spring Boot (Java, Maven)**  
  ‚Üí Fournit l‚ÄôAPI REST, la logique m√©tier et la persistance des donn√©es.  
- **Frontend Electron (JavaScript, Node.js)**  
  ‚Üí Fournit une interface utilisateur l√©g√®re et multiplateforme, communiquant avec le backend local.  

### Sch√©ma simplifi√©

```
[Electron UI] ‚áÑ [API REST - Spring Boot] ‚áÑ [Base de donn√©es / Services internes]
```

---

### Organisation des r√©pertoires

| Dossier / Fichier | R√¥le principal |
|--------------------|----------------|
| `src/main/java/...` | Code source Spring Boot (contr√¥leurs, services, mod√®les) |
| `src/main/resources/` | Configuration, templates, fichiers statiques |
| `pom.xml` | Configuration Maven du backend |
| `electron-shell/` | Application Electron (interface utilisateur) |
| `electron-shell/start.sh` | Script de lancement combin√© backend + UI |
| `doc/` | Documentation technique (cahier des charges, diagrammes UML, etc.) |

---

## 2. Couche Backend (Spring Boot)

Le backend suit une structure **en couches logiques** :

| Couche | Contenu | R√¥le |
|--------|----------|------|
| **Controller** | Classes REST exposant les endpoints (`@RestController`) | G√®re les requ√™tes HTTP et les r√©ponses JSON |
| **Service** | Logique m√©tier et orchestration des donn√©es | Centralise les traitements applicatifs |
| **Repository** | Interfaces Spring Data JPA (`extends JpaRepository`) | Communication avec la base de donn√©es |
| **Model / Entity** | Classes m√©tiers annot√©es `@Entity` | Repr√©sentation des objets persist√©s |

Cette s√©paration permet :
- Une meilleure testabilit√© (mock des d√©pendances)
- Une maintenance facilit√©e
- Une √©volution modulaire du code

---

## 3. Couche Frontend (Electron)

L‚Äôinterface Electron s‚Äôappuie sur :
- **Node.js** pour ex√©cuter du JavaScript c√¥t√© client  
- **Electron** pour encapsuler une interface Web dans une application de bureau  
- Un **fichier `index.html`** minimal qui sert de point d‚Äôentr√©e graphique

Electron communique avec le backend via des appels HTTP (`fetch`, `axios`, etc.) sur `http://localhost:8080`.

---

## 4. Diagramme d‚Äô√©tat ‚Äî Gestion des transitions applicatives

Le diagramme suivant illustre la logique d‚Äô√©tat principale de l‚Äôapplication (connexion, interaction sociale et combat) :

```mermaid
stateDiagram-v2
direction LR

[*] --> HORS_LIGNE : D√©marrage App

state CONNECT√â {
    direction LR
    
    [*] --> HUB
    
    state SOCIAL {
        direction TB
        [*] --> DIALOGUE
        DIALOGUE --> ECHANGE : INIT_TRADE
        ECHANGE --> DIALOGUE : END_TRADE / ABORT
    }

    state COMBAT {
        direction TB
        [*] --> ATTENTE_TOUR
        ATTENTE_TOUR --> ACTION : TOUR_COMMENC√â
        ACTION --> ATTENTE_TOUR : ACTION_FINIE
        
        ACTION --> MORT : TAKE_DAMAGE[si HP <= 0]
    }
    
    HUB --> COMBAT : START_COMBAT
    COMBAT --> HUB : END_COMBAT
    
    HUB --> SOCIAL : START_DIALOGUE
    SOCIAL --> HUB : END_SOCIAL
    
    MORT --> HUB : RESURRECT
}

HORS_LIGNE --> CONNECT√â : LOGIN
CONNECT√â --> HORS_LIGNE : LOGOUT

HORS_LIGNE --> MORT : LOGIN[si compte banni]
MORT --> HORS_LIGNE : LOGOUT
```

### Objectif du diagramme
Ce **state machine** d√©crit la navigation logique entre les √©tats :
- Gestion du cycle de vie d‚Äôun joueur (connexion / d√©connexion / bannissement)
- Navigation entre les sous-√©tats **HUB**, **SOCIAL**, et **COMBAT**
- Gestion des transitions internes et √©v√©nements (trade, combat, mort, r√©surrection)

Cette mod√©lisation soutient la **s√©paration des contextes m√©tier** et facilite la **gestion des transitions asynchrones** c√¥t√© serveur.

---

## 5. Principes SOLID

Les **principes SOLID** guident la conception orient√©e objet du backend (Spring Boot).

| Principe | Nom complet | Application dans le projet |
|-----------|-------------|-----------------------------|
| **S** | **Single Responsibility Principle**<br>(Responsabilit√© unique) | Chaque classe a un r√¥le clair (ex : un `UserService` ne g√®re que la logique des utilisateurs). |
| **O** | **Open/Closed Principle**<br>(Ouvert √† l‚Äôextension, ferm√© √† la modification) | Les services peuvent √™tre √©tendus via de nouvelles impl√©mentations ou strat√©gies, sans modifier le code existant. |
| **L** | **Liskov Substitution Principle**<br>(Substitution de Liskov) | Les impl√©mentations peuvent remplacer leurs abstractions sans casser le comportement du code (ex : `Repository` g√©n√©riques). |
| **I** | **Interface Segregation Principle**<br>(S√©gr√©gation des interfaces) | Les interfaces d√©finissent des contrats pr√©cis, adapt√©s aux besoins (√©vite les interfaces ‚Äúfourre-tout‚Äù). |
| **D** | **Dependency Inversion Principle**<br>(Inversion des d√©pendances) | Le code d√©pend d‚Äôabstractions (interfaces, services inject√©s via `@Autowired`) et non de classes concr√®tes. |

---

## 6. Avantages de l‚Äôarchitecture adopt√©e

- **S√©paration claire des responsabilit√©s** (backend / frontend / documentation)
- **Extensibilit√©** : ajout de modules, services ou endpoints sans couplage excessif
- **R√©utilisabilit√©** : composants modulaires et testables
- **Coh√©rence technique** entre Maven, Java 17+, Node 18+
- **Portabilit√©** : Electron permet un d√©ploiement multiplateforme (Windows, macOS, Linux)

---

## 7. Bonnes pratiques associ√©es

- Utiliser l‚Äô**encodage UTF-8** (configur√© dans `pom.xml`)
- Respecter les **conventions de nommage** Java et Node
- Centraliser la **configuration** (`application.properties`, variables d‚Äôenvironnement)
- √âviter les **d√©pendances circulaires** entre couches
- Versionner uniquement le **code source et les fichiers de configuration**
- Documenter les classes cl√©s et exposer un **diagramme UML** √† jour dans `/doc`

---

**üìò R√©f√©rence interne :**  
Ce document fait partie du *dossier d‚Äôarchitecture technique*.  
Il compl√®te les sections *Cahier des charges* et *Diagrammes UML* dans le r√©pertoire [`doc/`](./doc).

